# Vue2

## 前言

### Vue2 和 React 的对比

**（一）标准答案：**

1. 数据流：
   - react 主张函数式编程，所以推崇纯组件，数据不可变，单向数据流。
   - vue 的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立 Watcher 来监听，当属性变化的时候，响应式的更新对应的虚拟 dom。
2. 监听数据变化实现原理：
   - Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能。
   - React 默认是通过比较引用的方式进行的，如果不优化(PureComponent/shouldComponentUpdate)可能导致大量不必要的 VDOM 的重新渲染。
3. 组件通信的区别：
   - jsx 和.vue 模板。
   - HoC 和 Mixins(在 Vue 中我们组合不同功能的方式是通过 Mixin，而在 React 中我们通过 HoC(高阶组件))。
4. 性能优化：
   - React: shouldComponentUpdate
   - Vue:内部实现 shouldComponentUpdate 的优化，由于依赖追踪系统存在，通过 watcher 判断是否需要重新渲染(当一个页面数据量较大时，Vue 的性能较差，造成页面卡顿，所以一般数据比较大的项目倾向使用 React)。

**（二）其他答案：**

1. React 出现比 Vue 早，大厂一开始就用 React
2. React 社区更加完善，有大厂背书，Vue 主要是 Vue 自己的团队
3. 双向数据绑定会导致数据管理难度增加，单向数据流更加简单可控
4. React 组件即是函数，函数编程范式，可测试性更好
5. Vue 的 mixin，如果对项目不熟悉的人，调试难度大，改造难度大，很多时候可能都不知道 mixin 中用了什么， mixin 中如果混入了其他 mixin 难度更大
6. 高阶组件，React 可以对组件再封装，Vue 主要是通过 mixin 来扩展
7. 跨端能力 RN 比起 Weex 更加成熟

## 一、生命周期

每个 Vue 实例在创建时都会经过一系列的初始化过程，vue 的生命周期钩子，就是说在达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件

- beforeCreate 阶段： 创建前，此时 data 和 methods 中的数据都还没有初始化
- created 阶段：vue 实例被创建创建完毕，data 中有值，未挂载
- beforeMount 阶段：可以发起服务端请求，获取数据
- mount 阶段： vue 实例被挂载到真实 DOM 节点，此时可以操作 Dom
- beforeUpdate 阶段： 当 vue 实例里面的 data 数据变化时，触发组件的重新渲染前触发
- update 阶段：触发组件的重新渲染后触发
- beforeDestroy 阶段：实例被销毁前，此时可以手动销毁一些方法
- destroy 阶段：vue 实例被销毁

## 二、Vue2.x 组件通信方式

### （一）Vue2.x 组件通信共有 12 种

1. props
2. $emit / v-on
3. .sync
4. v-model
5. ref
6. children/parent
7. attrs/listeners
8. provide / inject
9. EventBus
10. Vuex
11. $root
12. slot

### （二）父子组件通信可以用：

1. props
2. $emit / v-on
3. attrs/listeners
4. ref
5. .sync
6. v-model
7. parent

### （三）兄弟组件通信可以用：

1. EventBus
2. Vuex
3. $parent

### （四）跨层级组件通信可以用：

1. provide/inject
2. EventBus
3. Vuex
4. listeners
5. $root
