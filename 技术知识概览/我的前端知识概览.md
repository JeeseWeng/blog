<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [一、HTML 相关](#%E4%B8%80html-%E7%9B%B8%E5%85%B3)
  - [（一）html5 新特性、语义化](#%E4%B8%80html5-%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%AD%E4%B9%89%E5%8C%96)
  - [（二）浏览器渲染机制、重绘、重排](#%E4%BA%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%92)
- [二、CSS 相关](#%E4%BA%8Ccss-%E7%9B%B8%E5%85%B3)
  - [（一）CSS 盒子模型](#%E4%B8%80css-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B)
  - [（二）css 样式优先级](#%E4%BA%8Ccss-%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7)
  - [（三）什么是 BFC？BFC 的布局规则是什么？如何创建 BFC？BFC 应用？](#%E4%B8%89%E4%BB%80%E4%B9%88%E6%98%AF-bfcbfc-%E7%9A%84%E5%B8%83%E5%B1%80%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA-bfcbfc-%E5%BA%94%E7%94%A8)
  - [（四）H5 移动端 1px 问题以及 5 种解决方法](#%E5%9B%9Bh5-%E7%A7%BB%E5%8A%A8%E7%AB%AF-1px-%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A-5-%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95)
  - [（五）H5 移动端字体自适应 rem(也适用于宽高)方案](#%E4%BA%94h5-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%AD%97%E4%BD%93%E8%87%AA%E9%80%82%E5%BA%94-rem%E4%B9%9F%E9%80%82%E7%94%A8%E4%BA%8E%E5%AE%BD%E9%AB%98%E6%96%B9%E6%A1%88)
- [三、JS 相关](#%E4%B8%89js-%E7%9B%B8%E5%85%B3)
  - [（一）JS 数据类型、typeof、instanceof、类型转换](#%E4%B8%80js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Btypeofinstanceof%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2)
  - [（二）闭包(高频)](#%E4%BA%8C%E9%97%AD%E5%8C%85%E9%AB%98%E9%A2%91)
  - [（三）原型、原型链(高频)](#%E4%B8%89%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E9%AB%98%E9%A2%91)
  - [（四）this 指向、new 关键字](#%E5%9B%9Bthis-%E6%8C%87%E5%90%91new-%E5%85%B3%E9%94%AE%E5%AD%97)
  - [（五）作用域、作用域链、变量提升](#%E4%BA%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87)
  - [（六）继承(含 es6)、多种继承方式](#%E5%85%AD%E7%BB%A7%E6%89%BF%E5%90%AB-es6%E5%A4%9A%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F)
  - [（七）EventLoop（事件循环）](#%E4%B8%83eventloop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF)
  - [（八）ajax 与 axios](#%E5%85%ABajax-%E4%B8%8E-axios)
  - [（九）事件冒泡、捕获(委托)](#%E4%B9%9D%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E6%8D%95%E8%8E%B7%E5%A7%94%E6%89%98)
  - [（十）JS 函数柯里化](#%E5%8D%81js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96)
  - [（七）数据结构复杂度](#%E4%B8%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E6%9D%82%E5%BA%A6)
  - [（八）let in 与 let of 的区别](#%E5%85%ABlet-in-%E4%B8%8E-let-of-%E7%9A%84%E5%8C%BA%E5%88%AB)
  - [（九）前后端如何通信](#%E4%B9%9D%E5%89%8D%E5%90%8E%E7%AB%AF%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1)
- [四、ES6](#%E5%9B%9Bes6)
  - [（一）大概](#%E4%B8%80%E5%A4%A7%E6%A6%82)
  - [（二）ES6 里的 Symbol](#%E4%BA%8Ces6-%E9%87%8C%E7%9A%84-symbol)
  - [（三）ES6 里的 set 和 map](#%E4%B8%89es6-%E9%87%8C%E7%9A%84-set-%E5%92%8C-map)
  - [（四）普通函数和箭头函数的区别](#%E5%9B%9B%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB)
  - [（五）深拷贝如何解决循环引用问题](#%E4%BA%94%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98)
- [五、Vue](#%E4%BA%94vue)
  - [（一）简述 MVVM](#%E4%B8%80%E7%AE%80%E8%BF%B0-mvvm)
  - [（二）谈谈对 vue 生命周期的理解？](#%E4%BA%8C%E8%B0%88%E8%B0%88%E5%AF%B9-vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3)
  - [（三）computed 与 watch](#%E4%B8%89computed-%E4%B8%8E-watch)
  - [（四）v-for 中 key 的作用](#%E5%9B%9Bv-for-%E4%B8%AD-key-%E7%9A%84%E4%BD%9C%E7%94%A8)
  - [（五）vue 组件的通信方式](#%E4%BA%94vue-%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F)
  - [（六）常用指令](#%E5%85%AD%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4)
  - [（七）双向绑定实现原理](#%E4%B8%83%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86)
  - [（八）v-model 的实现以及它的实现原理？](#%E5%85%ABv-model-%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86)
  - [（九）nextTick 的实现](#%E4%B9%9Dnexttick-%E7%9A%84%E5%AE%9E%E7%8E%B0)
  - [（十）vnode 的理解，compiler 和 patch 的过程](#%E5%8D%81vnode-%E7%9A%84%E7%90%86%E8%A7%A3compiler-%E5%92%8C-patch-%E7%9A%84%E8%BF%87%E7%A8%8B)
  - [（十一） new Vue 后整个的流程](#%E5%8D%81%E4%B8%80-new-vue-%E5%90%8E%E6%95%B4%E4%B8%AA%E7%9A%84%E6%B5%81%E7%A8%8B)
    - [思考：为什么先注入再提供呢？？](#%E6%80%9D%E8%80%83%E4%B8%BA%E4%BB%80%E4%B9%88%E5%85%88%E6%B3%A8%E5%85%A5%E5%86%8D%E6%8F%90%E4%BE%9B%E5%91%A2)
  - [（十二）keep-alive 的实现](#%E5%8D%81%E4%BA%8Ckeep-alive-%E7%9A%84%E5%AE%9E%E7%8E%B0)
  - [（十三）vuex](#%E5%8D%81%E4%B8%89vuex)
  - [（十四）你怎么理解 Vue 中的 diff 算法?](#%E5%8D%81%E5%9B%9B%E4%BD%A0%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3-vue-%E4%B8%AD%E7%9A%84-diff-%E7%AE%97%E6%B3%95)
  - [（十五）你都做过哪些 Vue 的性能优化？](#%E5%8D%81%E4%BA%94%E4%BD%A0%E9%83%BD%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B-vue-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96)
    - [编码阶段](#%E7%BC%96%E7%A0%81%E9%98%B6%E6%AE%B5)
    - [用户体验](#%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C)
  - [（十六）你知道 Vue3 有哪些新特性吗？它们会带来什么影响？](#%E5%8D%81%E5%85%AD%E4%BD%A0%E7%9F%A5%E9%81%93-vue3-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E5%90%97%E5%AE%83%E4%BB%AC%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D)
    - [性能提升](#%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87)
    - [API 变动](#api-%E5%8F%98%E5%8A%A8)
    - [检测机制](#%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6)
  - [（十七）实现双向绑定 Proxy 与 Object.defineProperty 相比优劣如何?](#%E5%8D%81%E4%B8%83%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A-proxy-%E4%B8%8E-objectdefineproperty-%E7%9B%B8%E6%AF%94%E4%BC%98%E5%8A%A3%E5%A6%82%E4%BD%95)
  - [（十八）vue 的 key](#%E5%8D%81%E5%85%ABvue-%E7%9A%84-key)
  - [（十九）mapState, mapGetters, mapActions, mapMutations](#%E5%8D%81%E4%B9%9Dmapstate-mapgetters-mapactions-mapmutations)
  - [（二十）vue-router](#%E4%BA%8C%E5%8D%81vue-router)
  - [（二十一）v-if 与 v-for 为什么不建议一起使用](#%E4%BA%8C%E5%8D%81%E4%B8%80v-if-%E4%B8%8E-v-for-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8)
- [六、React](#%E5%85%ADreact)
  - [（一）React 中 key 的作用，有 key 没 key 有什么区别，比较同一层级节点什么意思？](#%E4%B8%80react-%E4%B8%AD-key-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%9C%89-key-%E6%B2%A1-key-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E6%AF%94%E8%BE%83%E5%90%8C%E4%B8%80%E5%B1%82%E7%BA%A7%E8%8A%82%E7%82%B9%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D)
  - [（二）对虚拟 dom 和 diff 算法的理解，实现 render 函数](#%E4%BA%8C%E5%AF%B9%E8%99%9A%E6%8B%9F-dom-%E5%92%8C-diff-%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E5%AE%9E%E7%8E%B0-render-%E5%87%BD%E6%95%B0)
  - [（三）React 组件之间通信方式？](#%E4%B8%89react-%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F)
  - [（四）如何解析 jsx](#%E5%9B%9B%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90-jsx)
  - [（五）生命周期都有哪几种，分别是在什么阶段做哪些事情？为什么要废弃一些生命周期？](#%E4%BA%94%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%83%BD%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%88%86%E5%88%AB%E6%98%AF%E5%9C%A8%E4%BB%80%E4%B9%88%E9%98%B6%E6%AE%B5%E5%81%9A%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BA%9F%E5%BC%83%E4%B8%80%E4%BA%9B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F)
  - [（六）关于 react 的优化方法](#%E5%85%AD%E5%85%B3%E4%BA%8E-react-%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95)
  - [（七）绑定 this 的几种方式](#%E4%B8%83%E7%BB%91%E5%AE%9A-this-%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F)
  - [（八）对 fiber 的理解](#%E5%85%AB%E5%AF%B9-fiber-%E7%9A%84%E7%90%86%E8%A7%A3)
  - [（九）setState 是同步还是异步的](#%E4%B9%9Dsetstate-%E6%98%AF%E5%90%8C%E6%AD%A5%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84)
  - [（十）Redux、React-Redux](#%E5%8D%81reduxreact-redux)
  - [（十一）对高阶组件的理解](#%E5%8D%81%E4%B8%80%E5%AF%B9%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3)
  - [（十二）可以用哪些方式创建 React 组件？](#%E5%8D%81%E4%BA%8C%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA-react-%E7%BB%84%E4%BB%B6)
  - [（十三）React 元素与组件的区别？](#%E5%8D%81%E4%B8%89react-%E5%85%83%E7%B4%A0%E4%B8%8E%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB)
- [七、框架通识](#%E4%B8%83%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%86)
  - [（一）Vue 与 React 对比？](#%E4%B8%80vue-%E4%B8%8E-react-%E5%AF%B9%E6%AF%94)
  - [（二）vuex 和 redux 之间的区别？](#%E4%BA%8Cvuex-%E5%92%8C-redux-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB)
- [八、浏览器](#%E5%85%AB%E6%B5%8F%E8%A7%88%E5%99%A8)
  - [（一）浏览器从输入 url 到渲染页面，发生了什么？](#%E4%B8%80%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%BE%93%E5%85%A5-url-%E5%88%B0%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88)
  - [（二）什么是同源策略](#%E4%BA%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5)
  - [（三）跨域通信的几种方式](#%E4%B8%89%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F)
  - [（四）浏览器的本地存储以及各自优劣](#%E5%9B%9B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E4%BB%A5%E5%8F%8A%E5%90%84%E8%87%AA%E4%BC%98%E5%8A%A3)
- [九、网络安全：理解 xss，csrf，ddos 攻击原理以及避免方式](#%E4%B9%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%90%86%E8%A7%A3-xsscsrfddos-%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E9%81%BF%E5%85%8D%E6%96%B9%E5%BC%8F)
  - [（一）XSS(Cross-Site Scripting，跨站脚本攻击)](#%E4%B8%80xsscross-site-scripting%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB)
  - [（二）CSRF（Cross-site request forgery）跨站请求伪造](#%E4%BA%8Ccsrfcross-site-request-forgery%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)
  - [（三）DDoS 又叫分布式拒绝服务](#%E4%B8%89ddos-%E5%8F%88%E5%8F%AB%E5%88%86%E5%B8%83%E5%BC%8F%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1)
- [十、计算机网络、HTTP 协议](#%E5%8D%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Chttp-%E5%8D%8F%E8%AE%AE)
  - [（一）TCP UDP 区别](#%E4%B8%80tcp-udp-%E5%8C%BA%E5%88%AB)
  - [（二）Http 和 Https 区别（高频）](#%E4%BA%8Chttp-%E5%92%8C-https-%E5%8C%BA%E5%88%AB%E9%AB%98%E9%A2%91)
  - [（三）GET 和 POST 区别（高频）](#%E4%B8%89get-%E5%92%8C-post-%E5%8C%BA%E5%88%AB%E9%AB%98%E9%A2%91)
  - [（四）HTTPS TLS 的四次握手](#%E5%9B%9Bhttps-tls-%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B)
  - [（五）http 特性以及状态码](#%E4%BA%94http-%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E7%8A%B6%E6%80%81%E7%A0%81)
  - [（六）http 三次握手](#%E5%85%ADhttp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)
  - [（七）http 四次挥手](#%E4%B8%83http-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B)
  - [（八）http1.0、http1.1、http2.0 的区别](#%E5%85%ABhttp10http11http20-%E7%9A%84%E5%8C%BA%E5%88%AB)
  - [（九）http 如何实现缓存](#%E4%B9%9Dhttp-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98)
  - [（十）输入 url 后 http 请求的完整过程](#%E5%8D%81%E8%BE%93%E5%85%A5-url-%E5%90%8E-http-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B)
  - [（十一）从输入 url 到展示的过程](#%E5%8D%81%E4%B8%80%E4%BB%8E%E8%BE%93%E5%85%A5-url-%E5%88%B0%E5%B1%95%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B)
  - [（十二）osi7 层模型，tcp5 层模型](#%E5%8D%81%E4%BA%8Cosi7-%E5%B1%82%E6%A8%A1%E5%9E%8Btcp5-%E5%B1%82%E6%A8%A1%E5%9E%8B)
- [十一、前端性能优化](#%E5%8D%81%E4%B8%80%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96)
  - [（一）前端性能优化的几种方式](#%E4%B8%80%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F)
  - [（二）webapck 优化与开启 gzip 压缩](#%E4%BA%8Cwebapck-%E4%BC%98%E5%8C%96%E4%B8%8E%E5%BC%80%E5%90%AF-gzip-%E5%8E%8B%E7%BC%A9)
  - [（三）代码优化](#%E4%B8%89%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96)
  - [（四）雅虎前端优化 35 条军规](#%E5%9B%9B%E9%9B%85%E8%99%8E%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96-35-%E6%9D%A1%E5%86%9B%E8%A7%84)
- [十二、前端工程化](#%E5%8D%81%E4%BA%8C%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96)
  - [（一）webpack 配置，webpack4.0 有哪些优化点](#%E4%B8%80webpack-%E9%85%8D%E7%BD%AEwebpack40-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%E7%82%B9)
  - [（二）webpack 如何实现代码分离](#%E4%BA%8Cwebpack-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E5%88%86%E7%A6%BB)
  - [（三）常见的 Webpack Loader? 如何实现一个 Webpack Loader](#%E4%B8%89%E5%B8%B8%E8%A7%81%E7%9A%84-webpack-loader-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-webpack-loader)
  - [（四）常见的 Webpack Plugin? 如何实现一个 Webpack Plugin](#%E5%9B%9B%E5%B8%B8%E8%A7%81%E7%9A%84-webpack-plugin-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-webpack-plugin)
  - [（五）对比 loader 和 plugin](#%E4%BA%94%E5%AF%B9%E6%AF%94-loader-%E5%92%8C-plugin)
  - [（六）前端模块化，CMD、AMD、CommonJS](#%E5%85%AD%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96cmdamdcommonjs)
    - [1. CommonJS](#1-commonjs)
    - [2. AMD](#2-amd)
    - [3. CMD](#3-cmd)
- [十三、面试手写代码系列](#%E5%8D%81%E4%B8%89%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97)
  - [（一）防抖](#%E4%B8%80%E9%98%B2%E6%8A%96)
  - [（二）节流](#%E4%BA%8C%E8%8A%82%E6%B5%81)
  - [（三）对象深浅拷贝](#%E4%B8%89%E5%AF%B9%E8%B1%A1%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D)
    - [1、浅拷贝](#1%E6%B5%85%E6%8B%B7%E8%B4%9D)
    - [2、深拷贝](#2%E6%B7%B1%E6%8B%B7%E8%B4%9D)
    - [3、js 解决循环引用对象的深拷贝问题](#3js-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98)
  - [（四）数组去重,数组对象去重](#%E5%9B%9B%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E5%8E%BB%E9%87%8D)
  - [（五）数组扁平化](#%E4%BA%94%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96)
- [十四、 数据结构](#%E5%8D%81%E5%9B%9B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
- [十五、 算法](#%E5%8D%81%E4%BA%94-%E7%AE%97%E6%B3%95)
- [十六、JavaScript 设计原则 && 常用设计模式](#%E5%8D%81%E5%85%ADjavascript-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99--%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)
  - [（一）常用设计原则](#%E4%B8%80%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99)
  - [（二）常用设计模式](#%E4%BA%8C%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)
  - [（三）编程技巧](#%E4%B8%89%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7)
- [十五、职业技能规划、人事面试](#%E5%8D%81%E4%BA%94%E8%81%8C%E4%B8%9A%E6%8A%80%E8%83%BD%E8%A7%84%E5%88%92%E4%BA%BA%E4%BA%8B%E9%9D%A2%E8%AF%95)
- [十六、离职原因](#%E5%8D%81%E5%85%AD%E7%A6%BB%E8%81%8C%E5%8E%9F%E5%9B%A0)
- [十七、其他](#%E5%8D%81%E4%B8%83%E5%85%B6%E4%BB%96)
  - [（二）英文介绍](#%E4%BA%8C%E8%8B%B1%E6%96%87%E4%BB%8B%E7%BB%8D)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 一、HTML 相关

### （一）html5 新特性、语义化

语义化标签 ： header nav main article section aside footer

语义化意味着顾名思义，HTML5 的语义化指的是合理正确的使用语义化的标签来创建页面结构，如 header,footer,nav 标签上即可以直观的知道这个标签的作用，而不是滥用 div。

语义化的优点有:

1. 代码结构清晰，易于阅读，利于开发和维护；
2. 方便其他设备解析（如屏幕阅读器）根据语义渲染网页；
3. 有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重。

### （二）浏览器渲染机制、重绘、重排

网页生成过程：

1. HTML 被 HTML 解析器解析成 DOM 树
2. CSS 则被 CSS 解析器解析成 CSSOM 树
3. 结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)
4. 生成布局（flow），即将所有渲染树的所有节点进行平面合成
5. 将布局绘制（paint）在屏幕上

## 二、CSS 相关

### （一）CSS 盒子模型

所有 HTML 元素可以看作盒子，在 CSS 中，"box model"这一术语是用来设计和布局时使用。

CSS 盒模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边距，边框，填充，和实际内容。

盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。

### （二）css 样式优先级

!important > style > id > class

### （三）什么是 BFC？BFC 的布局规则是什么？如何创建 BFC？BFC 应用？

BFC 是 Block Formatting Context 的缩写，即块格式化上下文。

BFC 是 CSS 布局的一个概念，是一个环境，里面的元素不会影响外面的元素。

1. 布局规则：Box 是 CSS 布局的对象和基本单位，页面是由若干个 Box 组成的。
2. 元素的类型和 display 属性，决定了这个 Box 的类型。
3. 不同类型的 Box 会参与不同的 Formatting Context。

创建：浮动元素 display：inline-block； position:absolute；

应用:

1. 分属于不同的 BFC 时,可以防止 margin 重叠
2. 清除内部浮动
3. 自适应多栏布局

### （四）H5 移动端 1px 问题以及 5 种解决方法

CSS 像素为 1px 宽的直线，在不同设备对应的物理像素是不同的，可能是 2 个或者 3 个物理像素,而设计师想要的 1px 宽的直线，其实就是 1 物理像素宽。

对于 CSS 而言，可以认为是 border: 0.5px;，这是多倍屏下能显示的最小单位。然而，并不是所有手机浏览器都能识别 border: 0.5px，有的系统里，0.5px 会被当成为 0px 处理，那么如何 1px 细线问题呢？

解决方案：

1. 使用 border-image 实现
2. 使用 background-image 实现
3. 使用 box-shadow 模拟边框
4. 伪元素+transform
5. 用 JS 计算 rem 基准值和 viewport 缩放值

用 JS 根据屏幕尺寸和 dpr 精确地设置不同屏幕所应有的 rem 基准值和 initial-scale 缩放值，这个 JS 方案完美解决了 1px 细线问题。

```
/* 设计稿是750,采用1：100的比例,font-size为100 * (docEl.clientWidth * dpr / 750) */
const docEl = document.documentElement;
const fontEl = document.createElement('style');
const metaEl = document.querySelector('meta[name="viewport"]');
const dpr = window.devicePixelRatio || 1; // 获取设备像素比
const rem = 100 * (docEl.clientWidth * dpr / 750); // 计算rem为1屏幕的大小
const scale = 1 / dpr;
// 设置viewport，进行缩放，达到高清效果
metaEl.setAttribute('content', 'width=' + dpr * docEl.clientWidth + ',initial-scale=' + scale + ',maximum-scale=' + scale + ', minimum-scale=' + scale + ',user-scalable=no');
// 设置data-dpr属性，留作的css hack之用，解决图片模糊问题和1px细线问题
docEl.setAttribute('data-dpr', dpr);
// 动态写入样式
docEl.firstElementChild.appendChild(fontEl);
fontEl.innerHTML = 'html{font-size:' + rem + 'px!important;}'; // 让字体以及其他样式1px为1物理像素
```

详细文章：[H5 移动端 1px 问题以及 5 种解决方法](../1.HTML/H5移动端1px问题以及5种解决方法.md)

### （五）H5 移动端字体自适应 rem(也适用于宽高)方案

1. 纯 css 方法, 精确度高，IOS 和 安卓 字体大小同等比例，1 rem = 10 px

说明：以 16px 为基准，在根元素 html 下，字体为 62.5%，此时 1rem=10px.

```
/* css代码 */
/* 在根元素html下，font-size 设置为62.5%; */
html {
  /* 10÷16=62.5% */
  font-size: 62.5%;
}

body {
  font-size: 12px;
  /* 12÷10=1.2 */
  font-size: 1.2rem;
}
```

2. 纯 css 方法, 精确度高，IOS 和 安卓 字体大小同等比例
3. 使用 JS，通过识别设备是 IOS 还是 安卓，用 JS 动态计算 rem 转换 px

## 三、JS 相关

### （一）JS 数据类型、typeof、instanceof、类型转换

1. JS 数据类型：（1）string、（2）number、（3）boolean、（4）null、（5）undefined、（6）object(function)、（7）array、（8）symbol。【（9）ES10 BigInt】
2. typeof 返回值是一个字符串，主要用来判断数据类型 返回值有 string、boolean、number、function、object、undefined
3. instanceof 返回值是布尔值，判断该对象是谁的实例
4. null 表示空对象；undefined 表示已在作用域中声明但未赋值的变量

### （二）闭包(高频)

闭包是指有权访问另一个函数作用域中变量的函数 —— 《JavaScript 高级程序设计》

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行 ——《你不知道的 JavaScript》

闭包用途：

1. 能够访问函数定义时所在的词法作用域(阻止其被回收)
2. 私有化变量
3. 模拟块级作用域
4. 创建模块

闭包缺点：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏

### （三）原型、原型链(高频)

- 原型: 对象中固有的`__proto__`属性，该属性指向对象的 prototype 原型属性。
- 原型链: 当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是我们新建的对象为什么能够使用 toString()等方法的原因。
- 特点: JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。

### （四）this 指向、new 关键字

**this 对象**

是执行上下文中的一个属性，它指向最后一次调用这个方法的对象，在全局函数中，this 等于 window，而当函数被作为某个对象调用时，this 等于那个对象。 在实际开发中，this 的指向可以通过四种调用模式来判断。

1. 函数调用，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。
2. 方法调用，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。
3. 构造函数调用，this 指向这个用 new 新创建的对象。
4. apply、call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。
   - apply 接收参数的是数组，
   - call 接受参数列表，
   - bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。

**new 一个新对象的过程**

1. 首先创建了一个新的空对象
2. 设置原型，将对象的原型设置为函数的 prototype 对象。
3. 让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
4. 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

### （五）作用域、作用域链、变量提升

1. **作用域**负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。(全局作用域、函数作用域、块级作用域)。
2. **作用域链**就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。

### （六）继承(含 es6)、多种继承方式

1. 以**原型链**的方式来实现继承
2. 使用**借用构造函数**的方式
3. **组合继承**：将原型链和借用构造函数组合起来使用的一种方式。
4. **原型式继承**
5. **寄生式继承**
6. **寄生式组合继承**

Tips：面向对象编程的三个特征：继承、封装、多态

### （七）EventLoop（事件循环）

JS 是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。

微任务队列的代表就是，Promise.then，MutationObserver，

宏任务的话就是 setImmediate setTimeout setInterval

### （八）ajax 与 axios

- ajax

ajax 是一种异步通信的方法，从服务端获取数据，达到局部刷新页面的效果。是对原生 XHR 的封装，为了达到我们跨越的目的，增添了对 JsonP 的支持。

异步的 javascript 和 xml，ajax 不是一门新技术，而是多种技术的组合，用于快速的创建动态页面，能够实现无刷新更新数据从而提高用户体验。

过程：

1. 创建 XMLHttpRequest 对象;
2. 调用 open 方法传入三个参数：请求方式(GET/POST)、url、同步异步(true/false);
3. 监听 onreadystatechange 事件，当 readystate 等于 4 时返回 responseText;
4. 调用 send 方法传递参数。

- axios

Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中；是请求资源的模块；通过 promise 对 ajax 的封装。

属性：url、method、data、responseType、.then、.catch

- ajax 与 axios 的区别

axios 是通过 Promise 实现对 ajax 技术的一种封装，就像 jquery 对 ajax 的封装一样。

详细文章：[ajax 和 axios 区别及优缺点](../3.JavaScript/ajax和axios区别及优缺点.md)

### （九）事件冒泡、捕获(委托)

- 事件冒泡：指在一个对象上触发某类事件，如果此对象绑定了事件，就会触发事件，如果没有，就会向这个对象的父级对象传播，最终父级对象触发了事件。

- 事件委托：本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为**事件代理**。

### （十）JS 函数柯里化

1. 参数复用
2. 提前确认
3. 延迟运行

```
// 普通的add函数
function add(x, y) {
    return x + y
}

// Currying后
function curryingAdd(x) {
    return function (y) {
        return x + y
    }
}

add(1, 2)           // 3
curryingAdd(1)(2)   // 3
```

<!-- ### （六）实现继承

1. 原型链继承

- 写个父类、子类
- 子类的原型为父类的实例
- 子类.prootype = new 父类
- 修正子类原型为子类本身
- 子类.prototype.constructor=子类
- new 子类即可调用父类方法

2.  构造函数继承

- 写个父类、子类
- 在子类中父类.call(this) -->

### （七）数据结构复杂度

### （八）let in 与 let of 的区别

示例：

```
let arrObj = [{name: 'aaa', age: 11}, {name: 'bbb', age: 22}, {name: 'ccc', age: 33}]
for(let i in arrObj){
  console.log("i:", i);   // i: 0 i: 1 i: 2
}
for(let i of arrObj){
  console.log("i:", i);   // i: {name: 'aaa', age: 11} i: {name: 'bbb', age: 22} i: {name: 'ccc', age: 33}
}
```

1. let in 遍历的是键
2. let of 遍历的是值

### （九）前后端如何通信

1. Ajax : 短连接
2. Websocket : 长连接，双向的
3. Form 表单（最原始的）

## 四、ES6

### （一）大概

1. 新增 symbol 类型 表示独一无二的值，用来定义独一无二的对象属性名;
2. const/let 都是用来声明变量,不可重复声明，具有块级作用域。存在暂时性死区，也就是不存在变量提升。(const 一般用于声明常量);
3. 变量的解构赋值(包含数组、对象、字符串、数字及布尔值,函数参数),剩余运算符(...rest);
4. 模板字符串(${data});
5. 扩展运算符(数组、对象);;
6. 箭头函数;
7. Set 和 Map 数据结构;
8. Proxy/Reflect;
9. Promise;
10. async 函数;
11. Class;
12. Module 语法(import/export)。

### （二）ES6 里的 Symbol

它的功能类似于一种标识唯一性的 ID，每个 Symbol 实例都是唯一的。
Symbol 类型的 key 是不能通过 Object.keys()或者 for...in 来枚举的，
它未被包含在对象自身的属性名集合(property names)之中。
所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用 Symbol 来定义。
// 使用 Object 的 API
Object.getOwnPropertySymbols(obj) // [Symbol(name)]
// 使用新增的反射 API

Reflect.ownKeys(obj) // [Symbol(name), 'age', 'title']

### （三）ES6 里的 set 和 map

- Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。构造函数 Map 可以接受一个数组作为参数。
- Set 对象允许你存储任何类型的值，无论是原始值或者是对象引用。它类似于数组，但是成员的值都是唯一的，没有重复的值。

### （四）普通函数和箭头函数的区别

1. 箭头函数是匿名函数，不能作为构造函数，不能使用 new
2. 箭头函数不绑定 arguments，取而代之用 rest 参数...解决
3. 箭头函数不绑定 this，会捕获其所在的上下文的 this 值，作为自己的 this 值
4. 箭头函数通过 call() 或 apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。
5. 箭头函数没有原型属性
6. 箭头函数不能当做 Generator 函数,不能使用 yield 关键字

**总结：**

1. 箭头函数的 this 永远指向其上下文的 this ，任何方法都改变不了其指向，如 call() , bind() , apply()
2. 普通函数的 this 指向调用它的那个对象

### （五）深拷贝如何解决循环引用问题

使用 WeakMap、set 或者 Map 作为哈希表作为存储，递归判断是否存在，不存在直接拷贝，存在则解构拷贝。

注：

- obj 对象存在循环引用时，打印它时是不会栈溢出
- 深拷贝 obj 时，才会导致栈溢出
- 对象的 key 是不能是对象

## 五、Vue

(vue 源码理解)

### （一）简述 MVVM

MVVM 是 Model-View-ViewModel 缩写，也就是把 MVC 中的 Controller 演变成 ViewModel。
Model 层代表数据模型，View 代表 UI 组件，ViewModel 是 View 和 Model 层的桥梁。
数据会绑定到 viewModel 层并自动将数据渲染到页面中，视图变化的时候会通知 viewModel 层更新数据。

### （二）谈谈对 vue 生命周期的理解？

每个 Vue 实例在创建时都会经过一系列的初始化过程，vue 的生命周期钩子，就是说在达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件。

- beforeCreate 阶段： 创建前，此时 data 和 methods 中的数据都还没有初始化
- created 阶段：vue 实例被创建完毕，data 中有值，未挂载
- beforeMount 阶段：可以发起服务端请求，获取数据
- mounted 阶段： vue 实例被挂载到真实 DOM 节点，此时可以操作 Dom
- beforeUpdate 阶段： 当 vue 实例里面的 data 数据变化时，触发组件的重新渲染前触发
- updated 阶段：触发组件的重新渲染后触发
- activated 阶段：被 keep-alive 缓存的组件激活时调用。
- deactivated 阶段：被 keep-alive 缓存的组件失活时调用。
- beforeDestroy 阶段：实例被销毁前，此时可以手动销毁一些方法
- destroy 阶段：vue 实例被销毁
- errorCaptured：在捕获一个来自后代组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。
- 默认情况下，如果全局的 config.errorHandler 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。

### （三）computed 与 watch

- watch 属性监听：

  是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作,监听属性的变化，需要在数据变化时执行异步或开销较大的操作时使用。

- computed 计算属性：

  属性的结果会被缓存，当 computed 中的函数所依赖的属性没有发生改变的时候，那么调用当前函数的时候结果会从缓存中读取。除非依赖的响应式属性变化时才会重新计算，主要当做属性来使用 computed 中的函数必须用 return 返回最终的结果 computed 更高效，优先使用。

- 使用场景：
  - computed：当一个属性受多个属性影响的时候使用，例：购物车商品结算功能；
  - watch：当一条数据影响多条数据的时候使用，例：搜索数据。

### （四）v-for 中 key 的作用

1. key 的作用主要是为了更高效的对比虚拟 DOM 中每个节点是否是相同节点;
2. Vue 在 patch 过程中判断两个节点是否是相同节点，key 是一个必要条件，渲染一组列表时，key 往往是唯一标识，所以如果不定义 key 的话，Vue 只能认为比较的两个节点是同一个，哪怕它们实际上不是，这导致了频繁更新元素，使得整个 patch 过程比较低效，影响性能;
3. 从源码中可以知道，Vue 判断循环节点是否相同时主要是判断两者的 key 和元素类型等，因此如果不设置 key,它的值就是 undefined，则可能永远认为这是两个相同的节点，只能进一步去检查子元素，然后发现不同去做更新操作，这造成了大量的 dom 更新操作，明显是不可取的。

### （五）vue 组件的通信方式

1.  props
2.  $emit / v-on
3.  .sync
4.  v-model
5.  ref
6.  children / parent
7.  attrs / listeners
8.  provide / inject
9.  EventBus
10. Vuex
11. $root
12. slot

- （1）父子组件通信

  - 父->子 `props`
  - 子->父 `$on`、`$emit`
  - 获取父子组件实例 `parent`、`children`、`Ref`
  - 获取实例的方式调用组件的属性或者方法 Provide、inject 官方不推荐使用，但是写组件库时很常用
  - Vuex

- （2）兄弟组件通信

  - EventBus 实现跨组件通信 Vue.prototype.$bus = new Vue()
  - Vuex

- （3）跨级组件通信

  - $attrs
  - $listeners
  - Provide
  - inject
  - Vuex

### （六）常用指令

- v-if：判断是否隐藏；
- v-for：数据循环出来；
- v-bind:class：绑定一个属性；
- v-model：实现双向绑定

### （七）双向绑定实现原理

当一个 Vue 实例创建时，Vue 会遍历 data 选项的属性，用 Object.defineProperty 将它们转为 getter/setter 并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而使它关联的组件得以更新。

### （八）v-model 的实现以及它的实现原理？

vue 中双向绑定是一个指令 v-model，可以绑定一个动态值到视图，同时视图中变化能改变该值。v-model 是语法糖，默认情况下相于:value 和@input。

### （九）nextTick 的实现

nextTick 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。

在 Vue 2.4 之前都是使用的 microtasks，但是 microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 microtasks，但在特殊情况下会使用 macrotasks，比如 v-on。

对于实现 macrotasks ，会先判断是否能使用 setImmediate ，不能的话降级为 MessageChannel ，以上都不行的话就使用 setTimeout。

### （十）vnode 的理解，compiler 和 patch 的过程

```
vnode 虚拟DOM节点 创建：
export function Vnode (){
    return {
        tag:'div',
        children: 'span',
        attr:'',
        text:'你好!'
    }
}

```

### （十一） new Vue 后整个的流程

1. initProxy：作用域代理，拦截组件内访问其它组件的数据。
2. initLifeCycle：建立父子组件关系，在当前组件实例上添加一些属性和生命周期标识。如 parent,refs,$children,\_isMounted 等。
3. initEvents：对父组件传入的事件添加监听，子组件创建事件子组件监听。
4. initRender：声明$slots 和 slots 和 createElement()等。
5. initInjections：注入数据，初始化 inject，一般用于组件更深层次之间的通信。
6. initState：数据响应式：初始化状态。很多选项初始化的汇总：data,methods,props,computed 和 watch。
7. initProvide：提供数据注入。

#### 思考：为什么先注入再提供呢？？

答：

1. 首先来自祖辈的数据要和当前实例的 data 等判重，相结合，所以注入数据的 initInjections 一定要在 InitState 的上面。
2. 从上面注入进来的东西在当前组件中转了一下又提供给后代了，所以注入数据也一定要在上面。

### （十二）keep-alive 的实现

作用：实现组件缓存

- 钩子函数：

```
`activated `组件渲染后调用
`deactivated `组件销毁后调用
```

原理：Vue.js 内部将 DOM 节点抽象成了一个个的 VNode 节点，keep-alive 组件的缓存也是基于 VNode 节点的而不是直接存储 DOM 结构。它将满足条件（pruneCache 与 pruneCache 的组件）在 cache 对象中缓存起来，在需要重新渲染的时候再将 vnode 节点从 cache 对象中取出并渲染。

- 配置属性：

1. include 字符串或正则表达式。只有名称匹配的组件会被缓存
2. exclude 字符串或正则表达式。任何名称匹配的组件都不会被缓存
3. max 数字、最多可以缓存多少组件实例

### （十三）vuex

vuex 是一个专门为 vue.js 应用程序开发的状态管理库。

核心概念：

1. state：单一状态树
2. getter：state 的计算属性
3. mutation 显示提交更改 state
4. action 类似 mutation，提交 mutation，可以包含任意异步操作，比如进行请求之后调用 mutation 更新 state
5. module(当应用变得庞大复杂，拆分 store 为具体的 module 模块)

### （十四）你怎么理解 Vue 中的 diff 算法?

在 js 中,渲染真实 DOM 的开销是非常大的, 比如我们修改了某个数据,如果直接渲染到真实 DOM, 会引起整个 dom 树的重绘和重排（回流）。那么有没有可能实现只更新我们修改的那一小块 dom 而不要更新整个 dom 呢？此时我们就需要先根据真实 dom 生成虚拟 dom， 当虚拟 dom 某个节点的数据改变后会生成有一个新的 Vnode, 然后新的 Vnode 和旧的 Vnode 作比较，发现有不一样的地方就直接修改在真实 DOM 上，然后使旧的 Vnode 的值为新的 Vnode。

diff 的过程就是调用 patch 函数，比较新旧节点，一边比较一边给真实的 DOM 打补丁。在采取 diff 算法比较新旧节点的时候，比较只会在同层级进行。
在 patch 方法中，首先进行树级别的比较
new Vnode 不存在就删除 old Vnode，
old Vnode 不存在就增加新的 Vnode，
都存在就执行 diff 更新。
当确定需要执行 diff 算法时，比较两个 Vnode，包括三种类型操作：属性更新，文本更新，子节点更新
新老节点均有子节点，则对子节点进行 diff 操作，调用 updatechidren
如果老节点没有子节点而新节点有子节点，先清空老节点的文本内容，然后为其新增子节点
如果新节点没有子节点，而老节点有子节点的时候，则移除该节点的所有子节点
老新老节点都没有子节点的时候，进行文本的替换

updateChildren
将 Vnode 的子节点 Vch 和 oldVnode 的子节点 oldCh 提取出来。
oldCh 和 vCh 各有两个头尾的变量 StartIdx 和 EndIdx，它们的 2 个变量相互比较，一共有 4 种比较方式。如果 4 种比较都没匹配，如果设置了 key，就会用 key 进行比较，在比较的过程中，变量会往中间靠，一旦 StartIdx>EndIdx 表明 oldCh 和 vCh 至少有一个已经遍历完了，就会结束比较。

### （十五）你都做过哪些 Vue 的性能优化？

#### 编码阶段

1. 尽量减少 data 中的数据，data 中的数据都会增加 getter 和 setter，会收集对应的 watcher
2. 如果需要使用 v-for 给每项元素绑定事件时使用事件代理
3. SPA 页面采用 keep-alive 缓存组件
4. 在更多的情况下，使用 v-if 替代 v-show
5. key 保证唯一
6. 使用路由懒加载、异步组件
7. 防抖、节流
8. 第三方模块按需导入
9. 长列表滚动到可视区域动态加载
10. 图片懒加载
11. SEO 优化
12. 预渲染
13. 服务端渲染 SSR
14. 打包优化
15. 压缩代码
16. Tree Shaking/Scope Hoisting
17. 使用 cdn 加载第三方模块
18. 多线程打包 happypack
19. splitChunks 抽离公共文件
20. sourceMap 优化

#### 用户体验

1. 骨架屏
2. PWA
3. 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启 gzip 压缩等。

### （十六）你知道 Vue3 有哪些新特性吗？它们会带来什么影响？

#### 性能提升

- 更小巧、更快速
- 支持自定义渲染器
- 支持摇树优化：一种在打包时去除无用代码的优化手段
- 支持 Fragments 和跨组件渲染

#### API 变动

- 模板语法 99%保持不变
- 原生支持基于 class 的组件，并且无需借助任何编译及各种 stage 阶段的特性
- 在设计时也考虑 TypeScript 的类型推断特性
- 重写虚拟 DOM 通过更多的编译时提示来减少运行时的开销
- 优化插槽生成可以单独渲染父组件和子组件
- 静态树提升降低渲染成本
- 基于 Proxy 的观察者机制节省内存开销
- 不兼容 IE11

#### 检测机制

- 更加全面、精准、高效，更具可调试式的响应跟踪

### （十七）实现双向绑定 Proxy 与 Object.defineProperty 相比优劣如何?

1. Object.definedProperty 的作用是劫持一个对象的属性，劫持属性的 getter 和 setter 方法，在对象的属性发生变化时进行特定的操作。而 Proxy 劫持的是整个对象。
2. Proxy 会返回一个代理对象，我们只需要操作新对象即可，而 Object.defineProperty 只能遍历对象属性直接修改。
3. Object.definedProperty 不支持数组，更准确的说是不支持数组的各种 API，因为如果仅仅考虑 arry[i] = value 这种情况，是可以劫持 的，但是这种劫持意义不大。而 Proxy 可以支持数组的各种 API。
4. 尽管 Object.defineProperty 有诸多缺陷，但是其兼容性要好于 Proxy。

### （十八）vue 的 key

key 的作用主要是为了高效的更新虚拟 DOM,其原理是 vue 在 patch 过程中通过 key 可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个 patch 过程更加高效，减少 DOM 操作量,提高性能。另外,若不设置 key 还可能在列表更新时引发一些隐蔽的 bug vue 中在使用相同标签名元素的过渡切换时,也会使用到 key 属性,其目的也是为了让 vue 可以区分它们，否则 vue 只会替换其内部属性而不会触发过渡效果。

### （十九）mapState, mapGetters, mapActions, mapMutations

当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，mapMutations 其实跟 mapState 的作用是类似的，将组件中的 methods 映射为 store.commit 调用。

### （二十）vue-router

路由就是用来解析 URL 实现不同页面之间的跳转，vue-router 通过 hash 与 History 两种方式实现前端路由，更新视图但不重新请求页面。是前端路由原理的核心之一。

两种路由模式：

1. hash 模式：

在浏览器中符号的“#”，以及#后面的字符称之为 hash，用 window.location.hash 读取；

特点：

- hash 虽然在 URL 中，但不被包括在 HTTP 请求中；用来指导浏览器动作，对服务端安全无副作用；hash 不会重加载页面。
- hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会出现 404 错误。

2. history 模式

history 采用 HTML5 的新特性；且提供了两个新方法：pushState()，replaceState() 可以对浏览器历史记录栈进行修改，以及 popState 事件的监听到状态变更。

特点:

history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 地址后加上/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。

这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。

3. 路由跳转方式

   - 编程式导航：`this.$router.push({path:'/newDetail/495'});`
   - 命名路由：`this.$router.push({name:'news',params:{userId:123}});`

4. 传参与接收：

   （1）分别是 query，params，动态路由传参

   （2）接收

   - 通过 query 方式传递过来的参数一般是通过`this.$route.query`接收
   - 通过 params 方式传递过来的参数一般是通过`this.$route.params`接收
   - 通过动态路由传参方式传递过来的参数一般是通过`this.$route.params`接收

5. 路由守卫使用的方式有几种？

   总结：失活组件的 beforeRouteLeave -> 全局的 beforeEach -> 组件的 beforeRouteUpdate -> 路由配置的 beforeEnter -> 组件的 beforeRouteEnter -> 全局的 beforeResolve -> 全局的 afterEach -> 全局的 beforeRouteEnter 的 next

   - （1）导航被触发。
   - （2）在失活的组件里调用 beforeRouteLeave 守卫。
   - （3）调用全局的 beforeEach 守卫。
   - （4）在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
   - （5）在路由配置里调用 beforeEnter。
   - （6）解析异步路由组件。
   - （7）在被激活的组件里调用 beforeRouteEnter。
   - （8）调用全局的 beforeResolve 守卫 (2.5+)。
   - （9）导航被确认。
   - （10）调用全局的 afterEach 钩子。
   - （11）触发 DOM 更新。
   - （12）调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。

### （二十一）v-if 与 v-for 为什么不建议一起使用

1. 首先,v-for 循环是作用在 dom 节点上的,如果同时使用的话，编译器会直接报错，告诉你 v-if 和 v-for 不能同时使用;
2. 在解析时先解析 v-for 再解析 v-if。 哪怕只渲染一小部分元素，也得在每次重新渲染的时候遍历整个列表，不论 active 是否发生了变化。如果 list 的数据有很多，就会造成性能低，页面可能卡顿的现象出现。

解决方法：

1. 如果遇到需要同时使用时可以考虑写成计算属性的方式，使用 computer 先计算完属性再去渲染模版；
2. 使用空标签 template，让 for 循环在 template 上面。

## 六、React

### （一）React 中 key 的作用，有 key 没 key 有什么区别，比较同一层级节点什么意思？

Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。

### （二）对虚拟 dom 和 diff 算法的理解，实现 render 函数

1. 虚拟 DOM 本质上是 JavaScript 对象,是对真实 DOM 的抽象表现。
2. diff 算法：状态变更时，记录新树和旧树的差异 最后把差异更新到真正的 dom 中 render 函数:
   根据 tagName 生成父标签,读取 props，设置属性，如果有 content，设置 innerHtml 或 innerText。
   如果存在子元素，遍历子元素递归调用 render 方法，将生成的子元素依次添加到父元素中，并返回根元素。

### （三）React 组件之间通信方式？

1. 父子组件：父->子直接用 Props,子->父用 callback 回调。
2. 非父子组件：用发布订阅模式的 Event 模块。
3. 项目复杂的话用 Redux、Mobx 等全局状态管理管库。
4. Context Api：context 会使组件复用性变差。Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法.如果你只是想避免层层传递一些属性，组件组合（component composition）有时候是一个比 context 更好的解决方案。
5. 组件组合缺点：会使高层组件变得复杂。

### （四）如何解析 jsx

React 方法：调用 React.createElement 函数创建对象。  
原理：安装 react 和 babel

```
遇到
    <div>123</div>
执行
React.createElement("div", "123");

遇到
    <div>
        <div>1</div>
        <div>2</div>
        <div>3</div>
    </div>
执行
    React.createElement("div",
        React.createElement("div", "1"),
        React.createElement("div", "2"),
        React.createElement("div", "3")
    )
// 也就是说，用react开发的时候只要你用到了jsx语法，那么不管你有没有用到React都必须import react from "react"
复制代码
```

### （五）生命周期都有哪几种，分别是在什么阶段做哪些事情？为什么要废弃一些生命周期？

componentWillMount、componentWillReceiveProps、componentWillUpdate 在 16 版本被废弃，在 17 版本将被删除，需要使用 UNSAVE\_前缀使用，目的是向下兼容。

```
class ExampleComponent extends React.Component {
  // 用于初始化 state
  constructor() {}
  // 用于替换 `componentWillReceiveProps` ，该函数会在初始化和 `update` 时被调用
  // 因为该函数是静态函数，所以取不到 `this`
  // 如果需要对比 `prevProps` 需要单独在 `state` 中维护
  static getDerivedStateFromProps(nextProps, prevState) {}
  // 判断是否需要更新组件，多用于组件性能优化
  shouldComponentUpdate(nextProps, nextState) {}
  // 组件挂载后调用
  // 可以在该函数中进行请求或者订阅
  componentDidMount() {}
  // 用于获得最新的 DOM 数据
  getSnapshotBeforeUpdate() {}
  // 组件即将销毁
  // 可以在此处移除订阅，定时器等等
  componentWillUnmount() {}
  // 组件销毁后调用
  componentDidUnMount() {}
  // 组件更新后调用
  componentDidUpdate() {}
  // 渲染组件函数
  render() {}
  // 以下函数不建议使用
  UNSAFE_componentWillMount() {}
  UNSAFE_componentWillUpdate(nextProps, nextState) {}
  UNSAFE_componentWillReceiveProps(nextProps) {}
}
```

### （六）关于 react 的优化方法

1. 代码层面：使用 return null 而不是 CSS 的 display:none 来控制节点的显示隐藏。保证同一时间页面的 DOM 节点尽可能的少。
2. props 和 state 的数据尽可能简单明了，扁平化。
3. 不要使用数组下标作为 key 利用
4. shouldComponentUpdate 和 PureComponent 避免过多
5. render function;render 里面尽量减少新建变量和 bind 函数。
6. 传递参数是尽量减少传递参数的数量。尽量将 props 和 state 扁平化，只传递 component 需要的 props（传得太多，或者层次传得太深，都会加重 shouldComponentUpdate 里面的数据比较负担），慎将 component 当作 props 传入。

### （七）绑定 this 的几种方式

- bind
- apply
- call
- 箭头函数

### （八）对 fiber 的理解

在 V16 版本中引入了 Fiber 机制。这个机制一定程度上的影响了部分生命周期的调用，并且也引入了新的 2 个 API （getDerivedStateFromProps、getSnapshotBeforeUpdate）来解决问题。

在之前的版本中，如果你拥有一个很复杂的复合组件，然后改动了最上层组件的 state，那么调用栈可能会很长

调用栈过长，再加上中间进行了复杂的操作，就可能导致长时间阻塞主线程，带来不好的用户体验。Fiber 就是为了解决该问题而生。

Fiber 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新。

### （九）setState 是同步还是异步的

答：setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。

setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，可以通过第二个参数 setState(partialState, callback) 中的 callback 拿到更新后的结果。

setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。

### （十）Redux、React-Redux

- Redux 的实现流程：  
  用户页面行为触发一个 Action，然后 Store 调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。Reducer 会返回新的 State。每当 state 更新之后，view 会根据 state 触发重新渲染。
- React-Redux:  
  Provider：从最外部封装了整个应用，并向 connect 模块传递 store。  
  Connect：
  1. 包装原组件，将 state 和 action 通过 props 的方式传入到原组件内部。
  2. 监听 store tree 变化，使其包装的原组件可以响应 state 变化

### （十一）对高阶组件的理解

高阶组件是参数为组件，返回值为新组件的函数。HOC 是纯函数，没有副作用。HOC 在 React 的第三方库中很常见，例如 Redux 的 connect 组件。

高阶组件的作用：

1. 代码复用，逻辑抽象，抽离底层准备（bootstrap）代码
2. 渲染劫持
3. State 抽象和更改
4. Props 更改

### （十二）可以用哪些方式创建 React 组件？

React.createClass()、ES6 class 和无状态函数（也可能是有状态函数）

### （十三）React 元素与组件的区别？

组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数。

## 七、框架通识

### （一）Vue 与 React 对比？

1. 数据流：
   - react 主张函数式编程，所以推崇纯组件，数据不可变，单向数据流。
   - vue 的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立 Watcher 来监听，当属性变化的时候，响应式的更新对应的虚拟 dom。
2. 监听数据变化实现原理：
   - Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能。
   - React 默认是通过比较引用的方式进行的，如果不优化(PureComponent/shouldComponentUpdate)可能导致大量不必要的 VDOM 的重新渲染。
3. 组件通信的区别：
   - jsx 和.vue 模板。
   - HoC 和 Mixins(在 Vue 中我们组合不同功能的方式是通过 Mixin，而在 React 中我们通过 HoC(高阶组件))。
4. 性能优化：
   - React: shouldComponentUpdate
   - Vue:内部实现 shouldComponentUpdate 的优化，由于依赖追踪系统存在，通过 watcher 判断是否需要重新渲染(当一个页面数据量较大时，Vue 的性能较差，造成页面卡顿，所以一般数据比较大的项目倾向使用 React)。

### （二）vuex 和 redux 之间的区别？

从实现原理上来说，最大的区别是两点：

1. Redux 使用的是不可变数据，而 Vuex 的数据是可变的。Redux 每次都是用新的 state 替换旧的 state，而 Vuex 是直接修改
2. Redux 在检测数据变化的时候，是通过 diff 的方式比较差异的，而 Vuex 其实和 Vue 的原理一样，是通过 getter/setter 来比较的(如果看 Vuex 源码会知道，其实他内部直接创建一个 Vue 实例用来跟踪数据变化)

## 八、浏览器

### （一）浏览器从输入 url 到渲染页面，发生了什么？

```
三个方面：
网络篇:
    构建请求
    查找强缓存
    DNS解析
    建立TCP连接(三次握手)
    发送HTTP请求(网络请求后网络响应)
浏览器解析篇:
    解析html构建DOM树
    解析css构建CSS树、样式计算
    生成布局树(Layout Tree)
浏览器渲染篇:
    建立图层树(Layer Tree)
    生成绘制列表
    生成图块并栅格化
    显示器显示内容
    最后断开连接：TCP 四次挥手
    (浏览器会将各层的信息发送给GPU,GPU会将各层合成,显示在屏幕上)
```

### （二）什么是同源策略

一个域下的 js 脚本未经允许的情况下，不能访问另一个域下的内容。  
通常判断跨域的依据是协议、域名、端口号是否相同，不同则跨域。  
同源策略是对 js 脚本的一种限制，并不是对浏览器的限制，像 img,script 脚本请求不会有跨域限制

### （三）跨域通信的几种方式

1. jsonp(利用 script 标签没有跨域限制的漏洞实现。缺点：只支持 GET 请求)
2. CORS(设置 Access-Control-Allow-Origin：指定可访问资源的域名)
3. postMessage(message, targetOrigin, [transfer])(HTML5 新增 API 用于多窗口消息、页面内嵌 iframe 消息传递),通过 onmessage 监听 传递过来的数据
4. Websocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。
5. Node 中间件代理
6. Nginx 反向代理
7. 各种嵌套 iframe 的方式，不常用

日常工作中用的最对的跨域方案是 CORS 和 Nginx 反向代理

### （四）浏览器的本地存储以及各自优劣

浏览器的本地存储主要分为 Cookie、WebStorage 和 IndexDB, 其中 WebStorage 又可以分为 localStorage 和 sessionStorage。

共同点:

都是保存在浏览器端、且同源的

不同点：

1. cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下 sessionStorage 和 localStorage 不会自动把数据发送给服务器，仅在本地保存。
2. 存储大小限制也不同
   - cookie 数据不能超过 4K，sessionStorage 和 localStorage 可以达到 5M
   - sessionStorage：仅在当前浏览器窗口关闭之前有效；
   - localStorage：始终有效，窗口或浏览器关闭也一直保存，本地存储，因此用作持久数据
   - cookie：只在设置的 cookie 过期时间之前有效，即使窗口关闭或浏览器关闭
3. 作用域不同
   - sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面
   - localstorage：在所有同源窗口中都是共享的，即使浏览器不关闭，数据仍然存在
   - cookie: 也是在所有同源窗口中都是共享的.也就是说只要浏览器不关闭，数据仍然存在

## 九、网络安全：理解 xss，csrf，ddos 攻击原理以及避免方式

### （一）XSS(Cross-Site Scripting，跨站脚本攻击)

是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。

避免方式：

1. url 参数使用 encodeURIComponent 方法转义
2. 尽量不用 InnerHtml 插入 HTML 内容
3. 使用特殊符号、标签转义符。

### （二）CSRF（Cross-site request forgery）跨站请求伪造

攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

避免方式：

1. 添加验证码
2. 使用 token
   - 服务端给用户生成一个 token，加密后传递给用户
   - 用户在提交请求时，需要携带这个 token
   - 服务端验证 token 是否正确

### （三）DDoS 又叫分布式拒绝服务

DDoS 又叫分布式拒绝服务，全称 Distributed Denial of Service，其原理就是利用大量的请求造成资源过载，导致服务不可用。

避免方式：

1. 限制单 IP 请求频率。
2. 防火墙等防护设置禁止 ICMP 包等。
3. 检查特权端口的开放。

## 十、计算机网络、HTTP 协议

### （一）TCP UDP 区别

1.`TCP`向上层提供面向连接的可靠服务 ，`UDP`向上层提供无连接不可靠服务。  
2.虽然 `UDP` 并没有 `TCP` 传输来的准确，但是也能在很多实时性要求高的地方有所作为。  
3.对数据准确性要求高，速度可以相对较慢的，可以选用`TCP`。

### （二）Http 和 Https 区别（高频）

1.`HTTP` 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头。  
2.`HTTP` 是不安全的，而 HTTPS 是安全的。  
3.`HTTP` 标准端口是 80 ，而 HTTPS 的标准端口是 443。  
4.`在OSI` 网络模型中，HTTP 工作于应用层，而 HTTPS 的安全传输机制工作在传输层。  
5.`HTTP` 无法加密，而 HTTPS 对传输的数据进行加密。  
6.`HTTP`无需证书，而 HTTPS 需要 CA 机构 wosign 的颁发的 SSL 证书。

### （三）GET 和 POST 区别（高频）

1.GET 在浏览器回退不会再次请求，POST 会再次提交请求。  
2.GET 请求会被浏览器主动缓存，POST 不会，要手动设置。  
3.GET 请求参数会被完整保留在浏览器历史记录里，POST 中的参数不会。  
4.GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有限制。  
5.GET 参数通过 URL 传递，POST 放在 Request body 中。  
6.GET 参数暴露在地址栏不安全，POST 放在报文内部更安全。  
7.GET 一般用于查询信息，POST 一般用于提交某种信息进行某些修改操作。  
8.GET 产生一个 TCP 数据包：浏览器会把 http header 和 data 一并发送出去；POST 产生两个 TCP 数据包：先发送 header 再发送 data。

### （四）HTTPS TLS 的四次握手

1. 客户端发送一个随机值，需要的协议和加密方式
2. 服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需要的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）
3. 客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书
4. 服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密

通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用**对称加密**的方式通信。

注：以上说明的都是 TLS 1.2 协议的握手情况，在 1.3 协议中，首次建立连接只需要一个 RTT，后面恢复连接不需要 RTT 了。

### （五）http 特性以及状态码

```
比如：
    200响应成功
    301永久重定向
    302临时重定向
    304资源缓存
    403服务器禁止访问
    404服务器资源未找到
    500 502服务器内部错误
    504 服务器繁忙
    1xx	Informational（信息状态码）	  接受请求正在处理
    2xx	Success（成功状态码）            请求正常处理完毕
    3xx	Redirection（重定向状态码）		 需要附加操作已完成请求
    4xx	Client Error（客户端错误状态码）	服务器无法处理请求
    5xx	Server Error（服务器错误状态码）	服务器处理请求出错
```

### （六）http 三次握手

- 第一步：客户端发送 SYN 报文到服务端发起握手，发送完之后客户端处于 SYN_Send 状态
- 第二步：服务端收到 SYN 报文之后回复 SYN 和 ACK 报文给客户端
- 第三步：客户端收到 SYN 和 ACK，向服务端发送一个 ACK 报文,客户端转为 established 状态，此时服务端收到 ACK 报文后也处于 established 状态，此时双方已建立了连接

### （七）http 四次挥手

刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：

1. 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。
2. 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。
3. 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态
4. 第四次挥手: 客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态
5. 服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

### （八）http1.0、http1.1、http2.0 的区别

1. 1.1 和 1.0 相比，1.1 可以一次传输多个文件
2. http1.x 解析基于文本，http2.0 （1）采用二进制格式，新增特性：（2）多路复用、（3）header 压缩、（4）服务端推送(静态 html 资源)

### （九）http 如何实现缓存

1.  强缓存：Expires(过期时间)/Cache-Control(no-cache)(优先级高)
2.  协商缓存：Last-Modified/Etag(优先级高)Etag 适用于经常改变的小文件 Last-Modefied 适用于不怎么经常改变的大文件
3.  强缓存策略和协商缓存策略：
    在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则服务器返回最新的资源给浏览器。

### （十）输入 url 后 http 请求的完整过程

建立 TCP 连接 -> 发送请求行 -> 发送请求头 -> （到达服务器）发送状态行 -> 发送响应头 -> 发送响应数据 -> 断 TCP 连接

### （十一）从输入 url 到展示的过程

1. DNS 解析
2. TCP 三次握手
3. 发送请求，分析 url，设置请求报文(头，主体)
4. 服务器返回请求的文件 (html)
5. 浏览器渲染
   - （1）HTML parser --> DOM Tree
     - 标记化算法，进行元素状态的标记
     - dom 树构建
   - （2）CSS parser --> Style Tree
     - 解析 css 代码，生成样式树
   - （3）attachment --> Render Tree
     - 结合 dom 树 与 style 树，生成渲染树
   - （4）layout: 布局
   - （5）GPU painting: 像素绘制页面

### （十二）osi7 层模型，tcp5 层模型

1. osi7 层模型：物理层-数据链路层-传输层-网络层-应用层-会话层-表示层
2. tcp5 层模型：物理层-数据链路层-传输层-网络层-应用层

## 十一、前端性能优化

### （一）前端性能优化的几种方式

1. 静态资源、接口数据使用浏览器缓存
2. 接口请求防抖、节流
3. 资源懒加载、预加载
4. 开启 Nginx gzip 压缩

### （二）webapck 优化与开启 gzip 压缩

1.  babel-loader 用 include 或 exclude 来帮我们避免不必要的转译，不转译 node_moudules 中的 js 文件其次在缓存当前转译的 js 文件，设置 loader: 'babel-loader?cacheDirectory=true';
2.  文件采用按需加载等等;
3.  在 request headers 中加上 accept-encoding:gzip，编码压缩传输;
4.  图片优化，采用 svg 图片或者字体图标;
5.  浏览器缓存机制，它又分为强缓存和协商缓存

### （三）代码优化

1. 事件代理
2. 事件的节流和防抖
3. 页面的回流和重绘

### （四）[雅虎前端优化 35 条军规](../14.性能优化/雅虎前端优化的35条军规.md)

## 十二、前端工程化

### （一）webpack 配置，webpack4.0 有哪些优化点

```
module.exports={
	entry: {},
	output: {},
	plugins: [],
	module: [rules:[{}]]
}
```

### （二）webpack 如何实现代码分离

1. 入口起点：使用 entry 配置手动地分离代码。
2. 防止重复：使用 CommonsChunkPlugin 去重和分离 chunk。
3. 动态导入：通过模块的内联函数调用来分离代码。

### （三）常见的 Webpack Loader? 如何实现一个 Webpack Loader

1. loader: 是一个导出为函数的 javascript 模块，根据 rule 匹配文件扩展名，处理文件的转换器。
2. file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)
3. url-loader： 与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)
4. image-loader：加载并且压缩图片文件
5. babel-loader：把 ES6 转换成 ES5
6. sass-loader：将 SCSS/SASS 代码转换成 CSS
7. css-loader：加载 CSS，支持模块化、压缩、文件导入等特性
8. style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS
9. postcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀
10. eslint-loader：通过 ESLint 检查 JavaScript 代码

### （四）常见的 Webpack Plugin? 如何实现一个 Webpack Plugin

plugin:本质是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

1. html-webpack-plugin：简化 HTML 文件创建 (依赖于 html-loader)
2. uglifyjs-webpack-plugin：压缩 js 文件
3. clean-webpack-plugin：目录清除
4. mini-css-extract-plugin：分离样式文件，CSS 提取为独立文件，支持按需加载 (替代 extract-text-webpack-plugin)

### （五）对比 loader 和 plugin

Loader：在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。

Plugin：在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。

### （六）前端模块化，CMD、AMD、CommonJS

#### 1. CommonJS

CommonJS 是服务器端模块的规范，由 Node 推广使用，webpack 也采用这种规范编写

- 规范：
  CommonJS 模块规范主要分为三部分：模块定义、模块标识、模块引用。
  - 模块定义：module 对象，在每一个模块中，module 对象代表该模块自身。 export 属性：module 对象的一个属性，它向外提供接口。输出模块变量的最好方法是使用 module.exports 对象。一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为 global 对象的属性。
  - 模块标识：传递给 require 方法的参数，必须是符合小驼峰命名的字符串，或者以 . 、.. 、开头的相对路径，或者绝对路径。
- 优势：
- 缺点：

#### 2. AMD

AMD 是运行在浏览器环境的一个异步模块定义规范 ，是 RequireJS 在推广过程中对模块定义的规范化产出。

- 规范：AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。
- 优点：用户体验好，因为没有延迟，依赖模块提前执行了。

#### 3. CMD

CMD 是一个通用模块定义规范；是 SeaJs 推广过程中对模块定义的规范化产出

- 规范：CMD 推崇依赖就近，只有在用到某个模块的时候才会去 require
- 优点：性能好，因为只有用户需要的时候才执行。

## 十三、面试手写代码系列

### （一）防抖

定义：触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。  
搜索框搜索输入。只需用户最后一次输入完，再发送请求，手机号、邮箱验证输入检测 onchange oninput 事件，窗口大小 Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。

```
const debounce = (fn, wait, immediate) => {
      let timer = null;
      return function (...args) {
        if (timer) clearTimeout(timer);
        if (immediate && !timer) {
          fn.call(this, args);
        }
        timer = setTimeout(() => {
          fn.call(this, args);
        }, wait);
      };
    };
const betterFn = debounce(() => console.log("fn 防抖执行了"), 1000, true);
document.addEventListener("scroll", betterFn);
```

### （二）节流

定义：当持续触发事件时，保证隔间时间触发一次事件。

1. 懒加载、滚动加载、加载更多或监听滚动条位置；
2. 百度搜索框，搜索联想功能；
3. 防止高频点击提交，防止表单重复提交；

```
function throttle(fn,wait){
    let pre = 0;
    return function(...args){
        let now = Date.now();
        if( now - pre >= wait){
            fn.apply(this,args);
            pre = now;
        }
    }
}
function handle(){
    console.log(Math.random());
}
window.addEventListener("mousemove",throttle(handle,1000));
```

### （三）对象深浅拷贝

#### 1、浅拷贝

1. Object.assign(target,source)
2. es6 对象扩展运算符(...)

#### 2、深拷贝

```
function deepClone(obj) {
      if (!obj || typeof obj !== "object") return;
      let newObj = Array.isArray(obj) ? [] : {};
      for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
          newObj[key] = typeof obj[key] === "object" ? deepClone(obj[key]) : obj[key];
        }
      }
      return newObj;
}
```

#### 3、js 解决循环引用对象的深拷贝问题

对象的 key 是不能是对象的。

```
function deepCopy (objs, map) {
  if (map == undefined) {
    map = new WeakMap() // 或 new Map()
  }

  if (objs === null || typeof objs != 'object') {
    return objs
  }
  if (map.get(objs)) {
    return objs
  }

  map.set(objs, objs)

  let newObjs = Array.isArray(objs) ? [] : {}
  let keys = Object.keys(objs)
  for (let i of keys) {
    newObjs[i] = deepCopy(objs[i], map)
  }
  return newObjs
}
```

拓展：

1. WeakMap 只接受对象作为 key，如果设置其他类型的数据作为 key，会报错。
2. WeakMap 的 key 所引用的对象都是弱引用，只要对象的其他引用被删除，垃圾回收机制就会释放该对象占用的内存，从而避免内存泄漏。
3. 由于 WeakMap 的成员随时可能被垃圾回收机制回收，成员的数量不稳定，所以没有 size 属性。
4. 没有 clear()方法
5. 不能遍历

### （四）数组去重,数组对象去重

```
//数组
const arr = [2,7,5,7,2,8,9];
console.log([...new Set(arr)]); // [2,7,5,8,9];
//对象
const list = [{age:18,name:'张三'},{age:18,name:'李四'},{age:18,name:'王五'}]
let hash = {};
const newArr = arr.reduce((item, next) => {
    hash[next.age] ? '' : hash[next.age] = true && item.push(next);
    return item;
}, []);
console.log(list);
```

### （五）数组扁平化

```
function flatten(arr) {
      return arr.reduce((result, item) => {
        return result.concat(Array.isArray(item) ? flatten(item) : item);
      }, []);
}
```

## 十四、 数据结构

## 十五、 算法

## 十六、JavaScript 设计原则 && 常用设计模式

资料地址：[JavaScript 设计原则与设计模式](../11.设计模式/JavaScript设计原则与设计模式.md)

### （一）常用设计原则

1. 单一职责原则 SRP
2. 最少知识原则 LKP
3. 开放-封闭原则 OCP

### （二）常用设计模式

1. 单例模式
2. 代理模式
3. 策略模式
4. 状态模式
5. 享元模式
6. 职责链模式
7. 装饰者模式
8. 发布-订阅模式

### （三）编程技巧

1. 提炼函数
2. 合并重复的条件片段
3. 把条件分支语句提炼成函数
4. 合理使用循环
5. 提前让函数退出代替嵌套条件分支
6. 传递对象参数代替过长的参数列表（面向对象编程--编程模式--配置对象）
7. 尽量减少参数数量
8. 少用三目运算符（三元运算符）
9. 合理使用链式调用
10. 分解大型类
11. 用 return 退出多重循环

## 十五、职业技能规划、人事面试

1. 未来准备往哪方面发展？精通/全干
2. 对于职业规划的个人见解
3. 自身价值的体现

## 十六、离职原因

1. 个人职业规划原因
2. 公司原因

主要是道一公司战略转换，不做政务类的项目了，而我之前是负责政务类项目的开发，大部分项目去年跟今年上半年已经做好了，公司给我任务只是维护之前的项目，修修 bug 之类的，虽然工作比较轻松，但是对于我来说，我是自驱型学习的性格，希望能继续有实际的项目开发，所以想要换个环境，继续在项目开发中提升自己，为公司做贡献。

## 十七、其他

### （二）英文介绍

Hello, Interviewer. My name is jiaxin weng. I am graduated from Guangdong police college, majoring in computer science and technology.Got the Bachelor degree in computer science.

I have ever worked in Guangzhou Baoju company and Guangzhou Jizhiyun company. At present, I am working at Guangdong Daoyi company.

I have front-end experience more than six years and have rich experience at HTML, CSSS, JavaScript, vue2, vue3 and react.

That is all that I want to introduce myself. Thanks
