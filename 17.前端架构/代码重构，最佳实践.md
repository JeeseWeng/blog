<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [代码重构，最佳实践](#%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5)
  - [一、WHAT：什么是重构？](#%E4%B8%80what%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E6%9E%84)
    - [（一）大型重构](#%E4%B8%80%E5%A4%A7%E5%9E%8B%E9%87%8D%E6%9E%84)
    - [（二）小型重构](#%E4%BA%8C%E5%B0%8F%E5%9E%8B%E9%87%8D%E6%9E%84)
  - [二、WHY：为什么要重构？](#%E4%BA%8Cwhy%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E6%9E%84)
  - [三、HOW：如何重构代码？](#%E4%B8%89how%E5%A6%82%E4%BD%95%E9%87%8D%E6%9E%84%E4%BB%A3%E7%A0%81)
    - [（一）灵活运用编程范式思想](#%E4%B8%80%E7%81%B5%E6%B4%BB%E8%BF%90%E7%94%A8%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%80%9D%E6%83%B3)
    - [（二）以设计原则为核心](#%E4%BA%8C%E4%BB%A5%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%BA%E6%A0%B8%E5%BF%83)
    - [（三）以 eslint 为基础手段](#%E4%B8%89%E4%BB%A5-eslint-%E4%B8%BA%E5%9F%BA%E7%A1%80%E6%89%8B%E6%AE%B5)
    - [（四）以渐进式持续重构代码为方法论](#%E5%9B%9B%E4%BB%A5%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%8C%81%E7%BB%AD%E9%87%8D%E6%9E%84%E4%BB%A3%E7%A0%81%E4%B8%BA%E6%96%B9%E6%B3%95%E8%AE%BA)
    - [（五）按金字塔原则对项目代码进行拆分](#%E4%BA%94%E6%8C%89%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E5%88%99%E5%AF%B9%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E6%8B%86%E5%88%86)
    - [（六）评估出每一个重构单元的耗时](#%E5%85%AD%E8%AF%84%E4%BC%B0%E5%87%BA%E6%AF%8F%E4%B8%80%E4%B8%AA%E9%87%8D%E6%9E%84%E5%8D%95%E5%85%83%E7%9A%84%E8%80%97%E6%97%B6)
    - [（七）正在做或规划中的业务单元顺手完成重构，其他部分安排空闲时间依次重构](#%E4%B8%83%E6%AD%A3%E5%9C%A8%E5%81%9A%E6%88%96%E8%A7%84%E5%88%92%E4%B8%AD%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%8D%95%E5%85%83%E9%A1%BA%E6%89%8B%E5%AE%8C%E6%88%90%E9%87%8D%E6%9E%84%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86%E5%AE%89%E6%8E%92%E7%A9%BA%E9%97%B2%E6%97%B6%E9%97%B4%E4%BE%9D%E6%AC%A1%E9%87%8D%E6%9E%84)
    - [（八）注意：](#%E5%85%AB%E6%B3%A8%E6%84%8F)
  - [四、WHEN：什么时候重构？](#%E5%9B%9Bwhen%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8D%E6%9E%84)
  - [五、BUG：重构会不会引入新的 BUG？](#%E4%BA%94bug%E9%87%8D%E6%9E%84%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%BC%95%E5%85%A5%E6%96%B0%E7%9A%84-bug)
  - [六、RISK（风险）：重构上线带来 BUG 的风险怎么解决？](#%E5%85%ADrisk%E9%A3%8E%E9%99%A9%E9%87%8D%E6%9E%84%E4%B8%8A%E7%BA%BF%E5%B8%A6%E6%9D%A5-bug-%E7%9A%84%E9%A3%8E%E9%99%A9%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3)
  - [七、FEASIBILITY（可行性）：如何让业务方意识到现阶段重构是必要的并同意？](#%E4%B8%83feasibility%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%84%8F%E8%AF%86%E5%88%B0%E7%8E%B0%E9%98%B6%E6%AE%B5%E9%87%8D%E6%9E%84%E6%98%AF%E5%BF%85%E8%A6%81%E7%9A%84%E5%B9%B6%E5%90%8C%E6%84%8F)
  - [八、PERFORMANCE（问题）：重构价值不被认可怎么办？](#%E5%85%ABperformance%E9%97%AE%E9%A2%98%E9%87%8D%E6%9E%84%E4%BB%B7%E5%80%BC%E4%B8%8D%E8%A2%AB%E8%AE%A4%E5%8F%AF%E6%80%8E%E4%B9%88%E5%8A%9E)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 代码重构，最佳实践

## 一、WHAT：什么是重构？

Martin Fowler：重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。

### （一）大型重构

1. 对象：对系统、模块、代码结构、类与类之间的关系等的重构
2. 方法：有分层垂直拆分、模块化水平拆分、解耦、抽象 UI 组件、抽象业务组件、抽象区块
3. 方法论：编程范式、设计原则、设计模式
4. 影响：代码改动多，影响面广，难度较大，耗时较长，引入 BUG 风险高

### （二）小型重构

1. 对象：对类、函数、变量等代码级别的重构
2. 方法：规范命名(见名知意)、规范注释、函数拆分、提取重复代码、eslint 等
3. 方法论：统一代码风格、制定规范、语义化编程、eslint
4. 影响：影响面小，难度小，次数频繁，引入 BUG 风险低

## 二、WHY：为什么要重构？

1. 软件最初设计的时候没有考虑到全部的功能和细节
2. 软件需求变更和持续迭代导致原先的设计已不适用
3. 消除破窗效应，当代码里面有了坏味道而不及时改善，容易破罐子破摔加速恶化

## 三、HOW：如何重构代码？

### （一）灵活运用编程范式思想

1. 面向对象
2. 面向过程
3. 函数式编程

### （二）以设计原则为核心

1. SOLID 原则：面向对象设计五大重要原则的首字母缩写，当我们设计类和模块时，遵守 SOLID 原则就如同它的名字一样：(solid， 可靠的)，可以让软件更加稳定、灵活和健壮。
   - （1）Single Responsibility Principle（SRP）：单一职责原则
   - （2）Open Closed Principle（OCP）：开闭原则
   - （3）Liskov Substitution Principle（LSP）：里氏替换原则
   - （4）Interface Segregation Principle（ISP）：接口隔离原则
   - （5）Dependence Inversion Principle（DIP）：依赖倒置原则

参考资料：https://blog.csdn.net/qq704072809/article/details/110351844

2. Kiss 原则：

   - （1）Keep It Simple and Stupid
   - （2）Keep It Short and Simple
   - （3）Keep It Simple and Straightforward.

参考资料：https://blog.csdn.net/qq_43141726/article/details/123537055

3. DRY 原则：Don’t Repeat Yourselt, 简称 DRY。不要重复自己，理解为不要写重复的代码。提高代码复用性

参考资料：https://blog.csdn.net/weixin_46156200/article/details/113436757

4. YAGNI 原则：
5. LOD 原则：
6. CRP 原则：

### （三）以 eslint 为基础手段

1. airbnb
2. standard
3. recommanded
4. prettier
5. 自定义

### （四）以渐进式持续重构代码为方法论

优点：持续集成、进度可控、过程可逆、不影响正常业务开发进度

### （五）按金字塔原则对项目代码进行拆分

1. 业务模块水平拆分
2. 代码分层垂直拆分

### （六）评估出每一个重构单元的耗时

1. 合理评估工作量
2. 权衡重构的性价比
3. 增加重构的可控性

### （七）正在做或规划中的业务单元顺手完成重构，其他部分安排空闲时间依次重构

### （八）注意：

1. 从 0->1 一次性完成重构的理想场景只存在于理想中。如果真实存在，只能说明项目过小或者已经趋于稳定迭代很少，这种情况要考虑是否真的有重构的必要！！！
2. 不要有了锤子(重构方法论)，就满世界去找钉子。不要为了重构而重构，做事要有目的性。
3. 重构不是软件开发的必要流程，而是现有代码的组织缺陷或不合理的补救方式。
4. 养成好的代码风格和 code review 的习惯避免代码的坏味道才是根本。

## 四、WHEN：什么时候重构？

1. 不要等到积重难返有了瓶颈之后再进行重构，大规模高层次的重构耗时耗力难度剧大
2. 应该建立起渐进式持续重构的意识，发现当前业务代码写的有问题就应该及时进行小规模的重构，而不是欠一屁股技术债

## 五、BUG：重构会不会引入新的 BUG？

会，所以怎么办呢？

1. 通过完整的单元测试保证重构前后的外部可见性一致；
2. 有条件的话找专业的测试进行**端到端测试**和**灰度测试**。

## 六、RISK（风险）：重构上线带来 BUG 的风险怎么解决？

需要及时通知业务方。如果不通知业务方直接将重构的代码上线，一旦出现问题，你肯定全责并且重构没有功劳也没有苦劳了

1. 必须通知业务方并说服业务方同意，让业务方做好准备上线后检查一下。如果真的引入了 bug 也不太会追责，因为在预期内并且我们的目标也是为了项目的长远发展呀
2. 有条件的话找专业的测试进行**端到端测试**和**灰度测试**

## 七、FEASIBILITY（可行性）：如何让业务方意识到现阶段重构是必要的并同意？

1. 让业务方、产品、测试看到开发中的痛点和技术上的瓶颈
2. 让所有人意识到缝缝补补破窗效应导致问题加剧，已经积重难返了
3. 强调重构带来的技术收益和业务收益
4. 提供切实可行并可控的重构计划方案

## 八、PERFORMANCE（问题）：重构价值不被认可怎么办？

明明是你代码写的烂才导致的重构，浪费时间，还有脸要绩效？想屁吃呢

1. 承认错误，承认自己会写 bug，表明没有不写 bug 的程序员（勇于担当并弱化责任，表明 owner 身份和地盘）【知耻而后勇】
2. 指出导致重构的其他原因：

   - （1）需求频繁变更，
   - （2）紧急需求倒排工时，
   - （3）没有将业务长期规划方向信息同步给开发，
   - （4）多人协作团队没有统一风格，
   - （5）团队没有 code review，
   - （6）没有 eslint 规范等等

（表明主要责任不在我，但是我意识到了问题并主动解决了，主动重构了）

3. 强调重构带来的优点：BUG 数量减少，维护成本下降，BUG 排查变快，开发速度增高等（业务价值才是绩效的根本）
